# 要求
**搭建包含信源编码、信道编码、调制解调的完整通信链路，评估误码率。**

# 编码原理
## Hamming码
汉明码（Hamming Code）是一种经典的**错误检测与纠正编码**，由理查德·汉明（Richard Hamming）于1950年提出，主要用于在数据传输或存储过程中**检测并纠正单比特错误**。以下是其核心要点：

---
### **1. 基本原理**
- **目的**：在数据中添加冗余位（校验位），通过奇偶校验机制发现并修正单个比特的错误。
- **关键特点**：
  - 可检测**1位错误**并**纠正**它。
  - 能检测（但不纠正）**2位错误**。
  - 适用于**突发错误较少**的场景（如内存、通信协议）。
---
### **2. 编码结构**
- **校验位位置**：位于数据位中位置为 \(2^k\) 的地方（如第1、2、4、8…位）。
- **数据位位置**：填充剩余的非2的幂次位置。
- **总码长**：若数据位数为 \(m\)，校验位数为 \(r\)，则满足$(2^r \geq m + r + 1)$。  
  （例如：4位数据需要3位校验，总码长7位，称为**汉明(7,4)码**）

---
### **3. 校验位计算**
每个校验位负责覆盖特定位置的比特（通过**二进制位置标记**的奇偶校验）：
- **校验位 \(p_k\)** 覆盖所有位置中第 \(k\) 位为1的数据位。  
  **例如**：
  - $(p_1)$（第1位）覆盖位置：1, 3, 5, 7…（二进制末位为1）
  - $(p_2)$（第2位）覆盖位置：2, 3, 6, 7…（二进制第二位为1）
  - 以此类推。
---
### **4. 错误检测与纠正**
1. **接收端重新计算校验位**，与原校验位对比。
2. **校验结果组合成错误位置**：  
   将不一致的校验位位置号相加（二进制形式直接拼接），得到的值即为错误比特的位置。  
   **例如**：若 $(p_1)$ 和 $(p_2)$ 不一致，错误位置为 $(1+2=3)$（第3位）。
---
### **5. 举例：汉明(7,4)码**
- **数据位**：$(d_3, d_5, d_6, d_7)$（第3、5、6、7位，值为1010）。  
- **校验位**：
  - $(p_1 = d_3 \oplus d_5 \oplus d_7 = 1 \oplus 0 \oplus 0 = 1)$
  - $(p_2 = d_3 \oplus d_6 \oplus d_7 = 1 \oplus 1 \oplus 0 = 0)$
  - $(p_4 = d_5 \oplus d_6 \oplus d_7 = 0 \oplus 1 \oplus 0 = 1)$  
- **完整编码**：$(p_1 p_2 d_3 p_4 d_5 d_6 d_7 = 1\ 0\ 1\ 1\ 0\ 1\ 0)$
- **若接收端第5位出错**（变为1），校验结果 $(p_1=1)$（一致）、$(p_2=1$)（不一致）、$(p_4=0)$（不一致），错误位置为 $(p_4 + p_2 = 4 + 2 = 6)$（实际应为5，需注意覆盖关系。
---
### **6. 优缺点**
- **优点**：高效的单比特纠错，冗余度低。
- **缺点**：无法处理多比特错误，需扩展（如扩展汉明码）。

汉明码是理解纠错编码的基础，后续更复杂的编码（如BCH码、Reed-Solomon码）均受其启发。

## 卷积码

卷积码是一种广泛应用于通信系统中的**前向纠错编码（FEC)** 技术，由彼得·埃利亚斯（Peter Elias）于1955年提出。与分组码（如汉明码）不同，卷积码具有**记忆特性**，其编码输出不仅取决于当前输入，还依赖于之前的输入序列。

---
### **1. 基本原理**
- **核心思想**：通过移位寄存器和模2加法器，将输入数据序列转换为具有冗余的编码序列。
- **关键参数**：
  - **约束长度（Constraint Length）** $(K)$：影响编码的记忆深度，通常定义为寄存器级数+1。
  - **码率（Code Rate）** $(R)$：输入比特数与输出比特数之比，如 $R=1/2$ 表示每1比特输入生成2比特输出。
---
### **2. 编码器结构**
卷积码编码器由以下部分组成：
1. **移位寄存器**：存储前 $(K-1)$ 个输入比特，提供"记忆"功能。
2. **模2加法器（异或运算）**：根据生成多项式组合寄存器中的比特，生成输出。

### **示例：$(2,1,3)$ 卷积码**
- **参数**：
  - 码率 $R=1/2$（1输入，2输出）
  - 约束长度 $K=3$（2级寄存器 + 当前输入）
- **生成多项式**：
  - $G_1 = (1,1,1)$（八进制表示为7）
  - $G_2 = (1,0,1)$（八进制表示为5）
- **编码过程**：
  - 输入比特 $(d_k)$ 与寄存器中前两比特 $(d_{k-1}, d_{k-2})$ 按多项式模2加：
    - 输出1：$d_k \oplus d_{k-1} \oplus d_{k-2}$
    - 输出2：$d_k \oplus d_{k-2}$
---

### **3. 状态图与网格图**
- **状态（State）**：由寄存器中的比特 $(d_{k-1}, d_{k-2})$ 决定，共 $2^{K-1}$ 种状态。
- **网格图（Trellis Diagram）**：描述所有可能状态转移的图形化工具，用于译码（如维特比算法）。

**示例状态转移**（输入比特=1）：
- 当前状态 $(00)$ → 输入1 → 新状态 $(10)$，输出 $G_1=1 \oplus 0 \oplus 0=1$，$G_2=1 \oplus 0=1$ → 输出 $(11)$。

---

### **4. 译码方法**
### **(1) 维特比算法（Viterbi Algorithm）**
- **最大似然译码**：通过网格图寻找最可能的路径（最小汉明距离或欧氏距离）。
- **步骤**：
  1. **分支度量计算**：比较接收序列与所有可能输出的距离。
  2. **路径累积度量**：保留到达每个状态的最小度量路径（幸存路径）。
  3. **回溯**：从最终最优状态反向追踪译码结果。

### **(2) 序列译码（Fano算法）**
适用于约束长度较大的卷积码，复杂度低但性能略差。

---

### **5. 性能特点**
- **纠错能力**：优于分组码（尤其在连续错误场景），性能随约束长度增加而提升。
- **编码增益**：在相同码率下，比未编码系统节省约3-6 dB的信噪比（SNR）。
- **典型应用**：
  - 卫星通信（DVB-S2）
  - 移动通信（GSM、3G/4G）
  - 深空通信（NASA标准）

### **6. 与其他编码对比**
| **特性**    | **卷积码**               | **分组码（如汉明码）** |
| --------- | --------------------- | ------------- |
| **记忆性**   | 有                     | 无             |
| **译码复杂度** | 较高（维特比算法）             | 低（查表）         |
| **适用场景**  | 连续错误（衰落信道）            | 随机单比特错误       |
| **典型码率**  | $R=1/2$, $2/3$, $3/4$ | $R=k/n$（如7/4） |
|           |                       |               |

---

### **7. 改进与变种**
- **删余卷积码（Punctured Codes）**：通过删除部分输出比特实现高码率（如 $R=3/4$）。
- **Turbo码**：将卷积码与交织器结合，逼近香农极限。
- **LDPC码**：现代替代方案，但卷积码仍因低延迟优势用于实时系统。

---
### **8. 示例计算**
**输入序列**：$(1, 0, 1, 1)$  
**初始状态**：$(00)$  
**输出计算**：
1. 输入1 → 输出 $(1\oplus0\oplus0, 1\oplus0) = (1,1)$，新状态 $(10)$
2. 输入0 → 输出 $(0\oplus1\oplus0, 0\oplus0) = (1,0)$，新状态 $(01)$
3. 输入1 → 输出 $(1\oplus0\oplus1, 1\oplus1) = (0,0)$，新状态 $(10)$
4. 输入1 → 输出 $(1\oplus1\oplus0, 1\oplus0) = (0,1)$，新状态 $(11)$  
**最终编码序列**：$(11, 10, 00, 01)$

---

卷积码因其**自适应纠错能力**和**高效实现**，成为无线通信的核心技术之一。理解其原理是学习现代编码理论（如5G Polar码）的重要基础。